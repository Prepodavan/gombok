package gen

import (
	"bytes"
	"github.com/Prepodavan/gombok/config"
	"github.com/dave/jennifer/jen"
	"github.com/wzshiming/gotype"
	"io"
	"strings"
	"unicode"
)

const DefaultHeader = "Code generated by gombok. DO NOT EDIT."

type Generator struct {
	input gotype.Type
	conf  *config.Config
	file  *jen.File
}

func (g *Generator) File() *jen.File {
	return g.file
}

type Option func(generator *Generator)

func WithJenFile(f *jen.File) Option {
	return func(generator *Generator) {
		generator.file = f
	}
}

func NewGenerator(src gotype.Type, config *config.Config, opts ...Option) (g *Generator) {
	g = &Generator{input: src, conf: config}
	for _, opt := range opts {
		opt(g)
	}
	return
}

func (g *Generator) WriteTo(w io.Writer) (n int64, err error) {
	if g.file == nil {
		g.file = jen.NewFilePath(g.input.PkgPath())
	}
	g.file.HeaderComment(DefaultHeader)
	g.generate()
	buf := &bytes.Buffer{}
	err = g.file.Render(buf)
	if err != nil {
		return
	}
	return io.Copy(w, buf)
}

func (g *Generator) generate() {
	set := make(map[string]struct{})
	for i := 0; i < g.input.NumChild(); i++ {
		child := g.input.Child(i)
		if child.Kind() == gotype.Declaration {
			child = child.Declaration()
		}
		if child.Kind() == gotype.Ptr {
			child = child.Elem()
		}
		if child.Kind() != gotype.Struct {
			continue
		}
		if _, ok := set[child.Name()]; ok {
			continue
		}
		g.genStruct(child)
		set[child.Name()] = struct{}{}
	}
}

type fieldWithOwner struct {
	field gotype.Type
	owner gotype.Type
}

func asParamName(in string) (out string) {
	out = strings.ToLower(in[:1]) + in[1:]
	if jen.IsReservedWord(out) {
		out = "_" + out
	}
	return
}

func (fwo *fieldWithOwner) Title(prefix string) string {
	return prefix + strings.Title(fwo.field.Name())
}

func (fwo *fieldWithOwner) paramName() string {
	return asParamName(fwo.field.Name())
}

func (g *Generator) genStruct(str gotype.Type) {
	for i := 0; i < str.NumField(); i++ {
		fwo := &fieldWithOwner{
			field: str.Field(i),
			owner: str,
		}
		if fwo.field.IsAnonymous() || fwo.field.Name() == "" {
			continue
		}
		fieldType := fwo.field.Elem()
		if !allowedKinds.contains(fieldType.Kind()) && !isBuiltin(fieldType) {
			continue
		}
		_, getField := str.FieldByName(fwo.Title(g.conf.GetterPrefix()))
		_, getMethod := str.MethodByName(fwo.Title(g.conf.GetterPrefix()))
		if !getField && !getMethod {
			g.getter(fwo)
		}
		_, setField := str.FieldByName(fwo.Title(g.conf.SetterPrefix()))
		_, setMethod := str.MethodByName(fwo.Title(g.conf.SetterPrefix()))
		if !setField && !setMethod {
			g.setter(fwo)
		}
	}
}

func (g *Generator) getter(field *fieldWithOwner) {
	var assigner func(field *fieldWithOwner) func(*jen.Statement)
	if g.conf.PtrReceiver() {
		assigner = g.ptrAssigner
	} else {
		assigner = g.notPtrAssigner
	}
	g.file.Line().Func().
		Params(
			jen.Id(g.receiverName(field.owner)).
				Do(g.receiverType(field.owner)),
		).
		Id(
			field.Title(
				g.conf.GetterPrefix(),
			),
		).
		Params().
		Params(
			jen.Do(
				g.param(field.field),
			),
		).
		Block(
			jen.Do(assigner(field)),
			jen.Return(),
		).
		Line()
}

func (g *Generator) setter(field *fieldWithOwner) {
	g.file.Line().Func().
		Params(
			jen.Id(g.receiverName(field.owner)).
				Do(g.receiverType(field.owner)),
		).
		Id(
			field.Title(
				g.conf.SetterPrefix(),
			),
		).
		Params(
			jen.Do(
				g.param(field.field),
			),
		).
		Block(
			jen.Id(g.receiverName(field.owner)).
				Dot(field.field.Name()).
				Op("=").
				Id(field.paramName()),
		).
		Line()
}

func (g *Generator) param(typ gotype.Type) func(stmt *jen.Statement) {
	return func(stmt *jen.Statement) {
		stmt.Id(asParamName(typ.Name())).Do(g.paramType(typ))
	}
}

func (g *Generator) ptrAssigner(field *fieldWithOwner) func(stmt *jen.Statement) {
	return func(stmt *jen.Statement) {
		stmt.
			If(
				jen.Id(g.receiverName(field.owner)).
					Op("!=").
					Nil(),
			).
			Block(jen.Do(g.notPtrAssigner(field)))
	}
}

func (g *Generator) notPtrAssigner(field *fieldWithOwner) func(stmt *jen.Statement) {
	return func(stmt *jen.Statement) {
		stmt.Id(field.paramName()).
			Op("=").
			Id(g.receiverName(field.owner)).
			Dot(field.field.Name())
	}
}

func (g *Generator) paramType(field gotype.Type) func(*jen.Statement) {
	return func(stmt *jen.Statement) {
		typ := field.Elem()
		next := stmt
		for !isBuiltin(typ) && typ.Kind() != gotype.Struct {
			kind := typ.Kind()
			switch kind {
			case gotype.Ptr:
				next = next.Op("*")
				typ = typ.Elem()
			case gotype.Slice:
				next = next.Index()
				typ = typ.Elem()
			case gotype.Array:
				next = next.Index(jen.Lit(typ.Len()))
				typ = typ.Elem()
			}
		}
		if typ.PkgPath() != field.PkgPath() {
			next.Qual(typ.PkgPath(), typ.Name())
		} else {
			next.Id(typ.Name())
		}
	}
}

func (g *Generator) receiverType(typ gotype.Type) func(*jen.Statement) {
	return func(stmt *jen.Statement) {
		if !g.conf.PtrReceiver() {
			stmt.Id(typ.Name())
		} else {
			stmt.Op("*").Id(typ.Name())
		}
	}
}

func (g *Generator) receiverName(typ gotype.Type) string {
	buf := &bytes.Buffer{}
	for _, sym := range typ.Name() {
		if unicode.IsUpper(sym) {
			buf.WriteRune(unicode.ToLower(sym))
		}
	}
	return buf.String()
}

type kinds []gotype.Kind

func (k kinds) contains(other gotype.Kind) bool {
	for _, cur := range k {
		if cur == other {
			return true
		}
	}
	return false
}

var allowedKinds = kinds{
	gotype.Ptr,
	gotype.Slice,
	gotype.Array,
	gotype.Struct,
}

func isBuiltin(t gotype.Type) bool {
	return t.Kind() < 22 && t.Kind() > 1
}
